<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Char&#39;s Blog</title>
  
  <subtitle>Jin Zhichao</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.charjin.top/"/>
  <updated>2021-07-03T08:52:44.778Z</updated>
  <id>https://blog.charjin.top/</id>
  
  <author>
    <name>Char Jin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>配置自己的MacOS开发环境</title>
    <link href="https://blog.charjin.top/2021/07/01/config-macos/"/>
    <id>https://blog.charjin.top/2021/07/01/config-macos/</id>
    <published>2021-07-01T08:32:04.000Z</published>
    <updated>2021-07-03T08:52:44.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac屏保"><a href="#Mac屏保" class="headerlink" title="Mac屏保"></a>Mac屏保</h2><p><a href="https://fliqlo.com/screensaver/" target="_blank" rel="noopener">Fliqlo - Screensaver</a></p><h2 id="科学上网环境"><a href="#科学上网环境" class="headerlink" title="科学上网环境"></a>科学上网环境</h2><ol start="0"><li><a href="https://github.com/yanue/V2rayU/releases" target="_blank" rel="noopener">安装V2ray Releases · yanue/V2rayU · GitHub</a></li><li>登录 <a href="http://v2sx.com" target="_blank" rel="noopener">http://v2sx.com</a></li></ol><h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><p>​    预备条件：</p><ul><li>修改终端类型为zsh：<code>sudo chsh -c /bin/zsh</code></li><li>安装Git：install xcode 工具包即可</li></ul><ol start="0"><li>安装iTerm2： <a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2 - macOS Terminal Replacement</a> <a href="https://iterm2.com/downloads/stable/latest" target="_blank" rel="noopener">点此下载</a></li><li>更换iTerm颜色：<a href="https://github.com/dracula/dracula-theme/releases" target="_blank" rel="noopener">Releases · dracula/dracula-theme · GitHub</a></li><li>安装 oh-my-zsh: <a href="https://ohmyz.sh/#install" target="_blank" rel="noopener">Oh My Zsh - a delightful &amp; open source framework for Zsh</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终端运行其一即可</span></span><br><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br><span class="line">sh -c "$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)"</span><br></pre></td></tr></table></figure><p>*<em>Download “install.sh” directly if network is unavailable *</em></p><ol start="3"><li><p>添加ohmyzsh插件：</p><ul><li><p>zsh-syntax-highlighting <code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></p></li><li><p>zsh-autosuggestions <code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></p></li><li><p>autojump <code>brew install autojump</code></p><p>需要python作为依赖项，brew将自动安装python，由于mac内置python因此安装后，使用<code>brew uninstall python@版本号</code>卸载</p></li></ul></li></ol><h2 id="包管理软件"><a href="#包管理软件" class="headerlink" title="包管理软件"></a>包管理软件</h2><ol start="0"><li><p><a href="http://brew.sh" target="_blank" rel="noopener">Brew</a></p><p><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></p><p>若网络不可用，则下载<a href="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</a>，使用<code>chmod +x install.sh</code>后手动执行安装</p><ul><li>更换brew源：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Homebrew</span><br><span class="line"> </span><br><span class="line">git -C "$(brew --repo)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"> </span><br><span class="line">git -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"> </span><br><span class="line">git -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span><br><span class="line"> </span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>brew默认安装位置为 <code>/usr/local/opt</code></p></li><li><p>Node.js (内置NPM) 用于Hexo博客</p><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download | Node.js (nodejs.org)</a></p><p>或者使用<code>brew install node@版本号</code>安装，便于指定安装版本以及 <strong>卸载</strong></p><blockquote><p>Node.js 安装地址</p><ul><li>Node.js v14.17.2 to /usr/local/bin/node</li><li>npm v6.14.13 to /usr/local/bin/npm</li></ul></blockquote><ul><li><p>修改镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> http://npm.taobao.org/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装cnpm替代npm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或将npm源修改为taobao镜像源（等价于在 ~/.npmrc 中添加 registry=https://registry.npm.taobao.org/）</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="SDK配置"><a href="#SDK配置" class="headerlink" title="SDK配置"></a>SDK配置</h2><ol start="0"><li><p>JDK安装 <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">Java SE - Downloads | Oracle Technology Network | Oracle</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Java Development Kit</span></span><br><span class="line">export JAVA_HOME=JDK根目录/Home</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>C/C++环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置<span class="built_in">alias</span></span></span><br><span class="line">alias gcc='gcc-11'</span><br><span class="line">alias g++='g++-11'</span><br><span class="line">alias cc='gcc-11'</span><br><span class="line">alias c++='c++-11'</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mac屏保&quot;&gt;&lt;a href=&quot;#Mac屏保&quot; class=&quot;headerlink&quot; title=&quot;Mac屏保&quot;&gt;&lt;/a&gt;Mac屏保&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://fliqlo.com/screensaver/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="开发环境" scheme="https://blog.charjin.top/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="mac" scheme="https://blog.charjin.top/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1026 Table Tennis (30分) (模拟问题)</title>
    <link href="https://blog.charjin.top/2020/04/27/pat-A1026/"/>
    <id>https://blog.charjin.top/2020/04/27/pat-A1026/</id>
    <published>2020-04-27T14:09:20.000Z</published>
    <updated>2021-04-03T04:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560" target="_blank" rel="noopener">A1026 Table Tennis (30分)</a></p><p>A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours.</p><p>Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day.</p><p>One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the priviledge to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <code>N</code> (≤10000) - the total number of pairs of players. Then <code>N</code> lines follow, each contains 2 times and a VIP tag: <code>HH:MM:SS</code> - the arriving time, <code>P</code> - the playing time in minutes of a pair of players, and <code>tag</code> - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: <code>K</code> (≤100) - the number of tables, and <code>M</code> (&lt; K) - the number of VIP tables. The last line contains <code>M</code> table numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">20:52:00 10 0</span><br><span class="line">08:00:00 20 0</span><br><span class="line">08:02:00 30 0</span><br><span class="line">20:51:00 10 0</span><br><span class="line">08:10:00 5 0</span><br><span class="line">08:12:00 10 1</span><br><span class="line">20:50:00 10 0</span><br><span class="line">08:01:30 15 1</span><br><span class="line">20:53:00 10 1</span><br><span class="line">3 1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08:00:00 08:00:00 0</span><br><span class="line">08:01:30 08:01:30 0</span><br><span class="line">08:02:00 08:02:00 0</span><br><span class="line">08:12:00 08:16:30 5</span><br><span class="line">08:10:00 08:20:00 10</span><br><span class="line">20:50:00 20:50:00 0</span><br><span class="line">20:51:00 20:51:00 0</span><br><span class="line">20:52:00 20:52:00 0</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><ul><li>题意：</li><li>思路：<ol start="0"><li>按照时间将运动员升序排序</li><li>从编号最低开始遍历所有桌子，找到最先空闲出来的桌子<ul><li>如果是普通桌子，直接分配给队列中的第一对运动员</li><li>如果是VIP桌子，则查找队列中的第一对VIP运动员，若不存在则分配给第一对运动员</li></ul></li><li>以上分配桌子时记录开始时间，开始时间减到达时间则为运动员的等待时间</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1026 Table 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="模拟" scheme="https://blog.charjin.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>7-46 新浪微博热门话题 (30分) (字符串解析)</title>
    <link href="https://blog.charjin.top/2020/03/30/pta-ds-7-46/"/>
    <id>https://blog.charjin.top/2020/03/30/pta-ds-7-46/</id>
    <published>2020-03-30T09:16:55.000Z</published>
    <updated>2020-04-04T15:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>PTA数据结构与算法题目集(中文)： <a href="https://pintia.cn/problem-sets/15/problems/893" target="_blank" rel="noopener">7-46 新浪微博热门话题 (30分)</a></p><p>新浪微博可以在发言中嵌入“话题”，即将发言中的话题文字写在一对“#”之间，就可以生成话题链接，点击链接可以看到有多少人在跟自己讨论相同或者相似的话题。新浪微博还会随时更新热门话题列表，并将最热门的话题放在醒目的位置推荐大家关注。</p><p>本题目要求实现一个简化的热门话题推荐功能，从大量英文（因为中文分词处理比较麻烦）微博中解析出话题，找出被最多条微博提到的话题。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入首先给出一个正整数<em>N</em>（≤10<sup>5</sup>），随后<em>N</em>行，每行给出一条英文微博，其长度不超过140个字符。任何包含在一对最近的<code>#</code>中的内容均被认为是一个话题，输入保证<code>#</code>成对出现。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>第一行输出被最多条微博提到的话题，第二行输出其被提到的微博条数。如果这样的话题不唯一，则输出按字母序最小的话题，并在第三行输出<code>And k more ...</code>，其中<code>k</code>是另外几条热门话题的条数。输入保证至少存在一条话题。</p><p>注意：两条话题被认为是相同的，如果在去掉所有非英文字母和数字的符号、并忽略大小写区别后，它们是相同的字符串；同时它们有完全相同的分词。输出时除首字母大写外，只保留小写英文字母和数字，并用一个空格分隔原文中的单词。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">This is a #test of topic#.</span><br><span class="line">Another #Test of topic.#</span><br><span class="line">This is a #Hot# #Hot# topic</span><br><span class="line">Another #hot!# #Hot# topic</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hot</span><br><span class="line">2</span><br><span class="line">And 1 more ...</span><br></pre></td></tr></table></figure><ul><li><p>题意：输入的每一行代表一条微博，其中一对#包裹的部分表示这条微博参与的“话题”（一条微博可以参与多个话题）。要求找出参与数最多的话题。话题由英文数字和其他非中文字符组成，两条话题去除非英文和数字的部分若相等则表示这两则话题相等。</p></li><li><p>分析：这题是 <a href="https://pintia.cn/problem-sets/15/problems/type/7" target="_blank" rel="noopener">数据结构与算法题目集（中文）</a>上通过率最低的题，通常字符串处理的题目是有些麻烦的，把思路理清也不会太难。主要分为以下几步骤：</p><ol start="0"><li>将一条微博中 <strong>#</strong> 包裹的topic解析出来</li><li>将取出的topic解析成两个字符串，一个是只包含的字母和数字并全转为小写，另一个则将所有单词用一个空格拼接且让首字母大写（即题目要求的输出格式）</li><li>设置名为 <strong>cnt</strong> 的无序map用于记录每个话题出现的次数，在一条微博中重复出现的话题也只当出现一次，因此需要用 <strong>exist</strong> 来记录是否出现过，若未出现过 <strong>cnt</strong> 才加1</li><li>为了方便排序，声明结构体用于保存答案</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">string</span> topic;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cnt != b.cnt ? a.cnt &gt; b.cnt : a.topic &lt; b.topic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">parse</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> &amp;outputTopic)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans, it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(s[i])) it += s[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[i]) || i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="string">""</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; it.length(); j++) &#123;</span><br><span class="line">                    ans += <span class="built_in">tolower</span>(it[j]);</span><br><span class="line">                    outputTopic += <span class="built_in">tolower</span>(it[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                outputTopic += <span class="string">' '</span>;</span><br><span class="line">                it = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outputTopic[<span class="number">0</span>] = <span class="built_in">toupper</span>(outputTopic[<span class="number">0</span>]);</span><br><span class="line">    outputTopic.erase(outputTopic.end() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; exist;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="built_in">string</span> originalTopic = s.substr(start, i - start), outputTopic;</span><br><span class="line">                    <span class="built_in">string</span> lowerTopic = parse(originalTopic, outputTopic);</span><br><span class="line">                    <span class="keyword">if</span> (!exist[lowerTopic]) &#123;</span><br><span class="line">                        exist[lowerTopic] = <span class="literal">true</span>;</span><br><span class="line">                        cnt[outputTopic]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : cnt) ans.push_back(&#123;it.second, it.first&#125;);</span><br><span class="line">    sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n%d\n"</span>, ans[<span class="number">0</span>].topic.c_str(), ans[<span class="number">0</span>].cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i].cnt != ans[<span class="number">0</span>].cnt) <span class="keyword">break</span>;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"And %d more ..."</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PTA数据结构与算法题目集(中文)： &lt;a href=&quot;https://pintia.cn/problem-sets/15/problems/893&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;7-46 新浪微博热门话题 (30分)&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串解析" scheme="https://blog.charjin.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1106 Lowest Price in Supply Chain (25分) (DFS+剪枝)</title>
    <link href="https://blog.charjin.top/2020/03/29/pat-A1106/"/>
    <id>https://blog.charjin.top/2020/03/29/pat-A1106/</id>
    <published>2020-03-29T01:18:55.000Z</published>
    <updated>2020-04-04T15:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464" target="_blank" rel="noopener">A1106 Lowest Price in Supply Chain (25分)</a></p><p>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.</p><p>Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price <em>P</em> and sell or distribute them in a price that is <em>r</em>% higher than <em>P</em>. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p><p>Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, The first line contains three positive numbers: <em>N</em> (≤10<sup>5</sup>), the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to <em>N</em>−1, and the root supplier’s ID is 0); <em>P</em>, the price given by the root supplier; and <em>r</em>, the percentage rate of price increment for each distributor or retailer. Then <em>N</em> lines follow, each describes a distributor or retailer in the following format:</p><p><em>K</em><sub><em>i</em></sub> ID[1] ID[2] … ID[<em>K</em><sub><em>i</em></sub>]</p><p>where in the <em>i</em>-th line, <em>K</em><sub><em>i</em></sub> is the total number of distributors or retailers who receive products from supplier <em>i</em>, and is then followed by the ID’s of these distributors or retailers. <em>K</em><sub><em>j</em></sub> being 0 means that the <em>j</em>-th member is a retailer. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 1010.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 1.80 1.00</span><br><span class="line">3 2 3 5</span><br><span class="line">1 9</span><br><span class="line">1 4</span><br><span class="line">1 7</span><br><span class="line">0</span><br><span class="line">2 6 1</span><br><span class="line">1 8</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.8362 2</span><br></pre></td></tr></table></figure><ul><li>题意：转述题意，一棵树中根结点是 <strong>供应商</strong>、叶子结点是 <strong>零售商</strong>、中间结点均为 <strong>经销商</strong>，零售商将供应商提供的商品销售出去需要经过一个或多个经销商，每经一个经销商价格都会增加 <strong>r%</strong>，问客户从零售商处购买商品可以得到的最低价格是多少，共有多少个零售商可以提供这样的最低价。</li><li>分析：这是树的深度优先搜索问题，在 <strong>dfs</strong> 函数中需要维护 <strong>当前结点编号</strong> 和 <strong>当前价格</strong> 两个参数，当到达叶子结点的时候判断当前价格是否小于最小价格即可。这里可以适当剪枝，即当price小于或等于最低价格时才继续向下搜索，但实际上提交代码后发现耗时没什么区别。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N], ans;</span><br><span class="line"><span class="keyword">int</span> n, k, cntMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> r, p, minPrice = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt; minPrice) &#123;</span><br><span class="line">            minPrice = price;</span><br><span class="line">            cntMin = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price == minPrice) &#123;</span><br><span class="line">            cntMin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : e[u]) &#123;</span><br><span class="line">        <span class="keyword">double</span> tempP = price * (<span class="number">1</span> + r / <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (tempP &lt;= minPrice) dfs(it, tempP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>, &amp;n, &amp;p, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            e[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f %d"</span>, minPrice, cntMin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1106 Lowest
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DFS" scheme="https://blog.charjin.top/tags/DFS/"/>
    
      <category term="深度优先搜索" scheme="https://blog.charjin.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【程序设计】信息工程学院学生信息变动Excel标注程序</title>
    <link href="https://blog.charjin.top/2020/03/23/python-info-comparison/"/>
    <id>https://blog.charjin.top/2020/03/23/python-info-comparison/</id>
    <published>2020-03-23T08:04:40.000Z</published>
    <updated>2020-03-23T12:25:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>点击右侧下载此程序：<a href="/信息工程学院变动标注程序32位.exe">信息工程学院变动标注程序32位.exe</a> | <a href="/信息工程学院变动标注程序64位.exe">信息工程学院变动标注程序64位.exe</a></p><p><strong>注意事项：</strong>此程序使用Python编写，所使用的Excel类库仅支持.xlsx新版表格格式，<u>使用前先转至Office或WPS中 <strong>将.xls另存为.xlsx格式</strong> </u>。另，Python程序执行速度较慢，数据量较多时执行时间将有所延长（约1分钟），出现的无响应情况并非程序崩溃，需耐心等待。</p><p><strong>使用方式：</strong>如图所示，点击 <strong>路径选择</strong> 分别选定昨日文件、今日文件与数据导出的位置（导出文件的名称由当前日期自动生成，也可修改），文本框的文件路径可手动输入，但亦出错（不推荐）。</p><p><img src="/img/python_info.png" alt="程序执行界面"></p><hr><ul><li>程序需求：因疫情问题，学院需每日统计学生的健康、出行以及学生所在社区的疫情情况等，并将当日的Excel统计数据比较于前一日的学生数据，将数据变动行填充为红色，变动处单元格填充为黄色。</li><li>程序设计：<ol><li>从便捷性与开发时间考虑，选用Python作为开发语言，使用 <strong>openpyxl</strong> 库处理Excel数据</li><li>算法思路：每日数据表格 <strong>格式完全一致</strong>，故逐行逐单元格比较，若出现单元格数值不相等则将其所在行标记为 <strong>有变动</strong>，并将当前单元格的列号存至列表 <strong>list_diff</strong> 中，其后将 <strong>变动行</strong> 所有单元格填充为红色（#FF0000），再通过 <strong>list_diff</strong> 将变动的单元格填充为黄色（#FFFF00）</li><li>考虑使非开发者可运行该脚本程序，为该程序添加图形界面，并将其打包成 <strong>.exe</strong> 可执行文件</li></ol></li><li>核心类库：<strong>time</strong>、<strong>tkinter</strong> 与 <strong>openpyxl</strong></li></ul><p>程序实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime, localtime</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> filedialog, Tk, Label, Entry, Button, StringVar</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> PatternFill</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles.fonts <span class="keyword">import</span> Font</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件类型</span></span><br><span class="line">file_type = [(<span class="string">'Excel文件类型'</span>, <span class="string">'.xlsx'</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要检查的列号</span></span><br><span class="line">check_col_numbers = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>,</span><br><span class="line">                     <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件选择框, 选择对比文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_opened_file_path</span><span class="params">(sv)</span>:</span></span><br><span class="line">    sv.set(filedialog.askopenfilename(</span><br><span class="line">        title=<span class="string">'选择文件路径'</span>,</span><br><span class="line">        filetypes=file_type,</span><br><span class="line">        defaultextension=<span class="string">'.xlsx'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件保存框, 选择导出文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_saved_file_path</span><span class="params">(sv)</span>:</span></span><br><span class="line">    current_date = strftime(<span class="string">"%Y_%m_%d"</span>, localtime())</span><br><span class="line">    sv.set(filedialog.asksaveasfilename(</span><br><span class="line">        title=<span class="string">'选择导出文件路径'</span>,</span><br><span class="line">        filetypes=file_type,</span><br><span class="line">        defaultextension=<span class="string">'.xlsx'</span>,</span><br><span class="line">        initialfile=<span class="string">'信息工程学院'</span> + current_date + <span class="string">'学生信息填报.xlsx'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比处理函数, 导出结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 存在空路径退出函数</span></span><br><span class="line">        <span class="keyword">if</span> file_today.get() == <span class="string">''</span> <span class="keyword">or</span> file_yesterday.get() == <span class="string">''</span> <span class="keyword">or</span> file_output.get() == <span class="string">''</span>:</span><br><span class="line">            messagebox.showinfo(<span class="string">"错误信息"</span>, <span class="string">"文件路径有误, 请重新选择!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 今日与昨日工作簿</span></span><br><span class="line">        wb_today = load_workbook(filename=file_today.get())</span><br><span class="line">        wb_yesterday = load_workbook(filename=file_yesterday.get())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 今日与昨日表</span></span><br><span class="line">        sheet_today = wb_today.worksheets[<span class="number">0</span>]</span><br><span class="line">        sheet_yesterday = wb_yesterday.worksheets[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 行号起始与结束编号</span></span><br><span class="line">        index_start, index_end = <span class="number">5</span>, sheet_today.max_row</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row_num <span class="keyword">in</span> range(index_start, index_end + <span class="number">1</span>):</span><br><span class="line">            is_changed = <span class="literal">False</span></span><br><span class="line">            list_diff = []</span><br><span class="line">            <span class="keyword">for</span> col_num <span class="keyword">in</span> check_col_numbers:</span><br><span class="line">                <span class="keyword">if</span> sheet_today.cell(row=row_num, column=col_num).value != sheet_yesterday.cell(row=row_num, column=col_num).value:</span><br><span class="line">                    <span class="comment"># 列表记录不同单元格列号</span></span><br><span class="line">                    list_diff.append(col_num)</span><br><span class="line">                    is_changed = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 不是完全相同的, 将该行填充为红色, 再将不同单元格填充为黄色</span></span><br><span class="line">            <span class="keyword">if</span> is_changed:</span><br><span class="line">                cnt = cnt + <span class="number">1</span></span><br><span class="line">                font = sheet_today.cell(row=row_num, column=col_num).font.copy(color=<span class="string">'00000000'</span>)</span><br><span class="line">                <span class="keyword">for</span> col_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">37</span> + <span class="number">1</span>):</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'FF0000'</span>)</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).font = font</span><br><span class="line">                <span class="keyword">for</span> col_num <span class="keyword">in</span> list_diff:</span><br><span class="line">                    sheet_today.cell(row=row_num, column=col_num).fill = PatternFill(<span class="string">'solid'</span>, fgColor=<span class="string">'FFFF00'</span>)</span><br><span class="line">        wb_today.save(file_output.get())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        messagebox.showinfo(<span class="string">"错误信息"</span>, <span class="string">"文件路径有误, 请重新选择!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wb_today.close()</span><br><span class="line">        wb_yesterday.close()</span><br><span class="line">        messagebox.showinfo(<span class="string">"提示信息"</span>, <span class="string">'已导出至储存路径, 共 %d 人信息变动'</span> % cnt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># tkinter库创建简单图形界面</span></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(<span class="string">'信息工程学院-学生信息改动标注 powered by 金'</span>)</span><br><span class="line">root.resizable(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">file_today, file_yesterday, file_output = StringVar(), StringVar(), StringVar()</span><br><span class="line">Label(root, text=<span class="string">'注: 仅支持.xlsx格式的Excel表格, .xls另存为至.xlsx做格式转换'</span>).grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line">Label(root, text=<span class="string">'昨日文件路径:'</span>).grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_yesterday).grid(row=<span class="number">1</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_opened_file_path(file_yesterday)).grid(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line">Label(root, text=<span class="string">'今日文件路径:'</span>).grid(row=<span class="number">2</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_today).grid(row=<span class="number">2</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_opened_file_path(file_today)).grid(row=<span class="number">2</span>, column=<span class="number">2</span>)</span><br><span class="line">Label(root, text=<span class="string">'保存路径:'</span>).grid(row=<span class="number">3</span>, column=<span class="number">0</span>)</span><br><span class="line">Entry(root, textvariable=file_output).grid(row=<span class="number">3</span>, column=<span class="number">1</span>, sticky=<span class="string">'we'</span>)</span><br><span class="line">Button(root, text=<span class="string">'路径选择'</span>, command=<span class="keyword">lambda</span>: select_saved_file_path(file_output)).grid(row=<span class="number">3</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Button(root, text=<span class="string">'点我导出 (非程序崩溃, Python程序需要1分钟处理数据)'</span>, command=solve).grid(row=<span class="number">4</span>, column=<span class="number">1</span>)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><ul><li>问题修复：由于原表内包含字体为红色的单元格，因此，若该行被填充为红色将导致其不可见地显示数值，添加功能——若某行为 <strong>变动行</strong>，则先将该行所有单元格字体颜色置为黑色，再行填充。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;点击右侧下载此程序：&lt;a href=&quot;/信息工程学院变动标注程序32位.exe&quot;&gt;信息工程学院变动标注程序32位.exe&lt;/a&gt; | &lt;a href=&quot;/信息工程学院变动标注程序64位.exe&quot;&gt;信息工程学院变动标注程序64位.exe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="程序设计" scheme="https://blog.charjin.top/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Python" scheme="https://blog.charjin.top/tags/Python/"/>
    
      <category term="openpyxl" scheme="https://blog.charjin.top/tags/openpyxl/"/>
    
      <category term="tkinter" scheme="https://blog.charjin.top/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】nohup 命令使用</title>
    <link href="https://blog.charjin.top/2020/03/07/linux-cmd-nohup/"/>
    <id>https://blog.charjin.top/2020/03/07/linux-cmd-nohup/</id>
    <published>2020-03-07T02:40:04.000Z</published>
    <updated>2020-03-07T05:58:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>用man查看一下说明，<strong>nohup - run a command immune to hangups, with output to a non-tty</strong></p><p>nohup 用来以非挂起的状态运行命令。</p><p>使用场景：比如使用java -jar 开启服务，exit 退出终端时避免杀死程序。</p><p>最后的 <strong>&amp;</strong> 表示后台运行</p><p><code>&gt; /dev/null</code> 和 <code>1 &gt; /dev/null</code> 含义一致，1 表示stdout标准输出，意为把标准输出重定向到/dev/null中，<strong>/dev/null</strong>是一个只写文件，里面的内容总会被丢弃，重定向到这个文件中相当于丢弃标准输出的内容。</p><p><code>2 &gt; &amp;1</code>中，2表示stderr标准错误，意为把标准输出重定向到 &amp;1 中，&amp;1 的含义就是引用标准输出的重定向位置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;命令格式：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.charjin.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://blog.charjin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1091 Acute Stroke (30分) (BFS广度优先搜索)</title>
    <link href="https://blog.charjin.top/2020/03/03/pat-A1091/"/>
    <id>https://blog.charjin.top/2020/03/03/pat-A1091/</id>
    <published>2020-03-03T15:15:32.000Z</published>
    <updated>2020-03-03T15:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072" target="_blank" rel="noopener">A1091 Acute Stroke (30分)</a></p><p>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 4 positive integers: <em>M</em>, <em>N</em>, <em>L</em> and <em>T</em>, where <em>M</em> and <em>N</em> are the sizes of each slice (i.e. pixels of a slice are in an <em>M</em>×<em>N</em> matrix, and the maximum resolution is 1286 by 128); <em>L</em> (≤60) is the number of slices of a brain; and <em>T</em> is the integer threshold (i.e. if the volume of a connected core is less than <em>T</em>, then that core must not be counted).</p><p>Then <em>L</em> slices are given. Each slice is represented by an <em>M</em>×<em>N</em> matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than <em>T</em> are counted. Two pixels are <strong>connected</strong> and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.</p><p><img src="https://images.ptausercontent.com/f85c00cc-62ce-41ff-8dd0-d1c288d87409.jpg" alt="Figure 1"></p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in a line the total volume of the stroke core.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 2</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">1 0 1 1</span><br><span class="line">0 1 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">1 0 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><ul><li>题意：计算中风核心块的体积是判断急性脑卒中的关键方法之一。题目给了一张三维的分析图，图中为1的点为中风块的可疑点，0则是正常的。现在给定阈值，如果某一区域的中风块数量大于给定阈值则视这块为病变区，现在要求计算总的病变区体积。</li><li>分析：这里显然是考察的BFS广度优先搜索，题目给定的是三维图，实际上二维的图没什么区别，二维中邻接点为相连的点（无向图中），这里的三维则是二维上的上下左右和第三维（即垂直方向）的上和下，一共是6个方向来表示邻接点。因此，首先用三维数组存储图，之后用X、Y、Z数组依次存放坐标改变的增量，这样用一个for循环遍历坐标的增量数组很轻松就能找到邻接点，之后和BFS同样的做法，用队列完成BFS。要注意的是，这里给定的三维的坐标，对于边界上的点，计算邻接点时会出现越界的情况的，那么相较于传统判断某点是否可访问的条件，这里还需要判断是否越界，越界了也是不能访问的。之后因为图可能是不连通的，所以需要将各个连通子图所得出的大于阈值的体积相加。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, l, t, e[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">int</span> X[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, Y[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    Z[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isVisitable</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || z &lt; <span class="number">0</span> || z &gt;= l) &amp;&amp;</span><br><span class="line">           e[z][x][y] != <span class="number">0</span> &amp;&amp; !inq[z][x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    q.push(a);</span><br><span class="line">    inq[a.z][a.x][a.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = now.x, y = now.y, z = now.z;</span><br><span class="line">        sum += e[z][x][y];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            x = now.x + X[i];</span><br><span class="line">            y = now.y + Y[i];</span><br><span class="line">            z = now.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span> (isVisitable(x, y, z)) &#123;</span><br><span class="line">                inq[z][x][y] = <span class="literal">true</span>;</span><br><span class="line">                q.push(&#123;x, y, z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= t ? sum : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e[k][i][j]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isVisitable(i, j, k)) ans += bfs(&#123;i, j, k&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1091 Acute 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="BFS" scheme="https://blog.charjin.top/tags/BFS/"/>
    
      <category term="广度优先搜索" scheme="https://blog.charjin.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1095 Cars on Campus (30分) (模拟问题)</title>
    <link href="https://blog.charjin.top/2020/03/01/pat-A1095/"/>
    <id>https://blog.charjin.top/2020/03/01/pat-A1095/</id>
    <published>2020-03-01T05:36:20.000Z</published>
    <updated>2020-03-01T05:51:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805371602845696" target="_blank" rel="noopener">A1095 Cars on Campus (30分)</a></p><p>Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with two positive integers <em>N</em> (≤10<sup>4</sup>), the number of records, and <em>K</em> (≤8×10<sup>4</sup>) the number of queries. Then <em>N</em> lines follow, each gives a record in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plate_number hh:mm:ss status</span><br></pre></td></tr></table></figure><p>where <code>plate_number</code> is a string of 7 English capital letters or 1-digit numbers; <code>hh:mm:ss</code> represents the time point in a day by hour:minute:second, with the earliest time being <code>00:00:00</code> and the latest <code>23:59:59</code>; and <code>status</code> is either <code>in</code> or <code>out</code>.</p><p>Note that all times will be within a single day. Each <code>in</code> record is paired with the chronologically next record for the same car provided it is an <code>out</code> record. Any <code>in</code> records that are not paired with an <code>out</code> record are ignored, as are <code>out</code> records not paired with an <code>in</code> record. It is guaranteed that at least one car is well paired in the input, and no car is both <code>in</code> and <code>out</code> at the same moment. Times are recorded using a 24-hour clock.</p><p>Then <em>K</em> lines of queries follow, each gives a time point in the format <code>hh:mm:ss</code>. Note: the queries are given in <strong>ascending</strong> order of the times.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">16 7</span><br><span class="line">JH007BD 18:00:01 in</span><br><span class="line">ZD00001 11:30:08 out</span><br><span class="line">DB8888A 13:00:00 out</span><br><span class="line">ZA3Q625 23:59:50 out</span><br><span class="line">ZA133CH 10:23:00 in</span><br><span class="line">ZD00001 04:09:59 in</span><br><span class="line">JH007BD 05:09:59 in</span><br><span class="line">ZA3Q625 11:42:01 out</span><br><span class="line">JH007BD 05:10:33 in</span><br><span class="line">ZA3Q625 06:30:50 in</span><br><span class="line">JH007BD 12:23:42 out</span><br><span class="line">ZA3Q625 23:55:00 in</span><br><span class="line">JH007BD 12:24:23 out</span><br><span class="line">ZA133CH 17:11:22 out</span><br><span class="line">JH007BD 18:07:01 out</span><br><span class="line">DB8888A 06:30:50 in</span><br><span class="line">05:10:00</span><br><span class="line">06:30:50</span><br><span class="line">11:00:00</span><br><span class="line">12:23:42</span><br><span class="line">14:00:00</span><br><span class="line">18:00:00</span><br><span class="line">23:59:00</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">JH007BD ZD00001 07:20:09</span><br></pre></td></tr></table></figure><ul><li>题意：浙江大学有8个校区和多个大门，每个门口都会记录车辆的进出时间，现在给定一天内车辆进出记录，要求根据指定时间输出当时的停车数量，最后输出停车时长最久的车辆。注：每辆车的进出记录都是匹配的，那些未匹配的记录将被舍弃。同时保证没有车辆在同一时刻进出。</li><li>分析：因为存在无效的记录，因此先把有效记录筛选出来，同时记录停车时长最久的车牌号。之后将有效记录按照时间顺序排序。最后，查询某一时刻的停车数时，如果总是遍历一遍记录，那不用试，肯定会超时的，所以先遍历一遍有效记录，将每个时刻的车辆数都记录下来，最后使用二分查找查找。记录数量的方式：在结构体中用<code>flag</code>将进和出分别标记为1和-1，那么遍历记录时，因为已经按照时间增序，所有flag的累加和就是当前时间时间点的车辆数。</li></ul><p>注意点：把输入的时间全转为秒，便于计算；最后输出的时间都是占两格的。二分查找的时候要如果查找成功，直接输出mid时刻的车辆数即可，如果查找失败，那应该输出小于所要查找时间的最大时刻记录下的数量，也就是right的当前位置。</p><p>最耗时的样例用了75ms，应该不算差了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> time, flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name != b.name ? a.name &lt; b.name : a.time &lt; b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpByTime</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123; <span class="keyword">return</span> a.time &lt; b.time; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, hh, mm, ss, maxP = <span class="number">-1</span>, tempCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> status;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;node&gt; record(n), validRecord;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; record[i].name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>, &amp;hh, &amp;mm, &amp;ss);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; status;</span><br><span class="line">        record[i].time = hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">        record[i].flag = status == <span class="string">"in"</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(record.begin(), record.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i].name == record[i + <span class="number">1</span>].name &amp;&amp;</span><br><span class="line">            record[i].flag == <span class="number">1</span> &amp;&amp; record[i + <span class="number">1</span>].flag == <span class="number">-1</span>) &#123;</span><br><span class="line">            validRecord.push_back(record[i]);</span><br><span class="line">            validRecord.push_back(record[i + <span class="number">1</span>]);</span><br><span class="line">            mp[record[i].name] += record[i + <span class="number">1</span>].time - record[i].time;</span><br><span class="line">            <span class="keyword">int</span> ptime = mp[record[i].name];</span><br><span class="line">            <span class="keyword">if</span> (ptime &gt; maxP) &#123;</span><br><span class="line">                maxP = ptime;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.push_back(record[i].name);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptime == maxP) &#123;</span><br><span class="line">                ans.push_back(record[i].name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(validRecord.begin(), validRecord.end(), cmpByTime);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; validRecord.size(); i++) &#123;</span><br><span class="line">        tempCnt += validRecord[i].flag;</span><br><span class="line">        cnt[validRecord[i].time] = tempCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>, &amp;hh, &amp;mm, &amp;ss);</span><br><span class="line">        <span class="keyword">int</span> time = hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = validRecord.size() - <span class="number">1</span>, mid, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (time &lt; validRecord[mid].time) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (time &gt; validRecord[mid].time) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[validRecord[mid].time]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[validRecord[right].time]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans) <span class="built_in">printf</span>(<span class="string">"%s "</span>, it.c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>, maxP / <span class="number">3600</span>, (maxP % <span class="number">3600</span>) / <span class="number">60</span>, maxP % <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805371602845696&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1095 Cars o
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="模拟问题" scheme="https://blog.charjin.top/tags/%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1087 All Roads Lead to Rome (30分) (Dijkstra+DFS)</title>
    <link href="https://blog.charjin.top/2020/02/29/pat-A1087/"/>
    <id>https://blog.charjin.top/2020/02/29/pat-A1087/</id>
    <published>2020-02-29T13:04:20.000Z</published>
    <updated>2020-02-29T13:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">A1087 All Roads Lead to Rome (30分)</a></p><p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (2≤<em>N</em>≤200), the number of cities, and <em>K</em>, the total number of routes between pairs of cities; followed by the name of the starting city. The next <em>N</em>−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then <em>K</em> lines follow, each describes a route between two cities in the format <code>City1 City2 Cost</code>. Here the name of a city is a string of 3 capital English letters, and the destination is always <code>ROM</code> which represents Rome.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p><p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format <code>City1-&gt;City2-&gt;...-&gt;ROM</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6 7 HZH</span><br><span class="line">ROM 100</span><br><span class="line">PKN 40</span><br><span class="line">GDN 55</span><br><span class="line">PRS 95</span><br><span class="line">BLN 80</span><br><span class="line">ROM GDN 1</span><br><span class="line">BLN ROM 1</span><br><span class="line">HZH PKN 1</span><br><span class="line">PRS ROM 2</span><br><span class="line">BLN HZH 2</span><br><span class="line">PKN GDN 1</span><br><span class="line">HZH PRS 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3 195 97</span><br><span class="line">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure><ul><li>题意：条条大路通罗马，在前往罗马的旅行路线中，除了起点每个地方都有它的开心值，两个地点之间存在行径费（如果两点连通），要求找到一条路径使得从起点到罗马途中的花销最小，如果路线不唯一则找到中开心值最大的路径，若仍不唯一则找到平均开心值最高的路径。输出花销最低的路径条数、花销、总开心值与平均开心值。</li><li>分析：这是单源最短路径问题，先用Dijkstra算法找出所有满足的花销最少的路径，然后用DFS依次筛选总开心值最高、同时第二尺标满足平均开心值最高的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> e[N][N], d[N], weight[N] = &#123;<span class="number">0</span>&#125;, n, m, st = <span class="number">0</span>, dest, cntPath = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[N], path, tempPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; e[u][v] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + e[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + e[u][v] == d[v]) &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxW = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">double</span> maxAvg = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        cntPath++;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; maxW) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tempAvg = sum * <span class="number">1.0</span> / cnt;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxW || (sum == maxW &amp;&amp; tempAvg &gt; maxAvg)) &#123;</span><br><span class="line">            maxW = sum;</span><br><span class="line">            maxAvg = tempAvg;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> next : pre[u]) dfs(next, sum + weight[next], cnt + <span class="number">1</span>);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, a, b;</span><br><span class="line">    <span class="built_in">string</span> start, s, city1, city2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; nametoid;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; idtoname;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; weight[i];</span><br><span class="line">        nametoid[s] = i;</span><br><span class="line">        idtoname[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + N * N, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> a = nametoid[city1], b = nametoid[city2];</span><br><span class="line">        e[a][b] = e[b][a] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    dest = nametoid[<span class="string">"ROM"</span>];</span><br><span class="line">    dijkstra(<span class="number">0</span>);</span><br><span class="line">    dfs(dest, weight[dest], <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n%s"</span>, cntPath, d[dest], maxW, (<span class="keyword">int</span>)maxAvg, start.c_str());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%s"</span>, idtoname[path[i]].c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS有两种写法，总体无异，这似乎也没法剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (pre[u].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempHp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tempPath.size(); i++) tempHp += hp[tempPath[i]];</span><br><span class="line">        <span class="keyword">double</span> tempAvg = tempHp * <span class="number">1.0</span> / (tempPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tempHp &gt; maxHp || (tempHp == maxHp &amp;&amp; tempAvg &gt; maxAvg)) &#123;</span><br><span class="line">            maxHp = tempHp;</span><br><span class="line">            maxAvg = tempAvg;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        cntRoute++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : pre[u]) dfs(v);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1087 All Ro
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="DFS" scheme="https://blog.charjin.top/tags/DFS/"/>
    
      <category term="Dijkstra最短路径算法" scheme="https://blog.charjin.top/tags/Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1119 Pre- and Post-order Traversals (30分) (前后序遍历序列建树)</title>
    <link href="https://blog.charjin.top/2020/02/28/pat-A1119/"/>
    <id>https://blog.charjin.top/2020/02/28/pat-A1119/</id>
    <published>2020-02-28T12:31:20.000Z</published>
    <updated>2020-03-03T15:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504" target="_blank" rel="noopener">A1119 Pre- and Post-order Traversals (30分)</a></p><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.</p><p>Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first printf in a line <code>Yes</code> if the tree is unique, or <code>No</code> if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 6 7 5</span><br><span class="line">2 6 7 4 5 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2 1 6 4 7 3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">2 1 3 4</span><br></pre></td></tr></table></figure><ul><li>题意：已知给定一个二叉树的前中序序列或后中序遍历序列能唯一确定一棵二叉树。现在给定一棵二叉树的前序和后序遍历序列，判断能否复原一棵二叉树，或者如果存在多个满足条件的二叉树，则输出任意一个中序遍历序列。</li><li>分析：先拿先序遍历举例，根据先序遍历的递归特性，一棵二叉树的先序遍历序列总会被分为3个部分【根+左子树先序序列+右子树先序序列】，后序遍历序列正好相反【左子树后序序列+右子树后序序列+根】，因此实际上先序遍历的根，它的右边一个数的就是这棵树左子树的根，之后在后序序列中找到这个数temp，那么后序序列的第一个数到temp这个数为止就是这颗树的左子树，因此就能将左右子树划分出来了，那什么时候是不能确定的呢？就是上面找到的temp在后序遍历序列的倒数第二个位置时就是不能确定的，因为它既可以做左子树又可以做右子树。最后不确定情况全当做左子树或者右子树，这样最后就能至少确定一棵树了（如果存在）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N], post[N], n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ansIn;</span><br><span class="line"><span class="keyword">bool</span> isunique = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel, <span class="keyword">int</span> prer, <span class="keyword">int</span> postl, <span class="keyword">int</span> postr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prel &gt; prer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (prel == prer) &#123;</span><br><span class="line">        ansIn.push_back(pre[prel]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = postl;</span><br><span class="line">    <span class="keyword">while</span> (post[k] != pre[prel + <span class="number">1</span>]) k++;</span><br><span class="line">    <span class="keyword">int</span> numRight = postr - k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numRight == <span class="number">0</span>) isunique = <span class="literal">false</span>;</span><br><span class="line">    create(prel + <span class="number">1</span>, prer - numRight, postl, k);</span><br><span class="line">    ansIn.push_back(pre[prel]);</span><br><span class="line">    create(prer - numRight + <span class="number">1</span>, prer, k + <span class="number">1</span>, postr - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isunique ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansIn.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ansIn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1119 Pre- a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://blog.charjin.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1107 Social Clusters (30分) (并查集)</title>
    <link href="https://blog.charjin.top/2020/02/28/pat-A1107/"/>
    <id>https://blog.charjin.top/2020/02/28/pat-A1107/</id>
    <published>2020-02-28T12:17:20.000Z</published>
    <updated>2020-02-28T13:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744" target="_blank" rel="noopener">A1107 Social Clusters (30分)</a></p><p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p><p><em>Ki</em>: <em>hi</em>[1] <em>hi</em>[2] … <em>hi</em>[<em>Ki</em>]</p><p>where <em>Ki</em> (&gt;0) is the number of hobbies, and <em>hi</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3: 2 7 10</span><br><span class="line">1: 4</span><br><span class="line">2: 5 3</span><br><span class="line">1: 4</span><br><span class="line">1: 3</span><br><span class="line">1: 4</span><br><span class="line">4: 6 8 1 5</span><br><span class="line">1: 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure><ul><li>题意：给出n个人的爱好，人物和爱好编号都为1到N，有同样爱好的人视作在一个群组，要求找出，这群人中有几个共同兴趣小组，输出群组数并按降序输出各组人数。</li><li>分析：需要用到并查集，同时，用<code>hobby</code>数组做哈希表标记谁有当前爱好，如果hobby是0则说明之前没记录过，需要记录一下，如果不为0，这找到其所在的群组，将当前的人合并到这个集合。之后遍历n个人，找到所有的群组并存到<code>unordered_map</code>中，再将结果转到vector中降序输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == father[x] ? x : father[x] = findFather(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) father[i] = i;</span><br><span class="line">    <span class="keyword">int</span> n, k, h, hobby[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d: "</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">            <span class="keyword">if</span> (hobby[h] != <span class="number">0</span>) uni(i, findFather(hobby[h]));</span><br><span class="line">            <span class="keyword">else</span> hobby[h] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mp[findFather(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) ans.push_back(it.second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1107 Social
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="并查集" scheme="https://blog.charjin.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1103 Integer Factorization (30分) (DFS+剪枝)</title>
    <link href="https://blog.charjin.top/2020/02/28/pat-A1103/"/>
    <id>https://blog.charjin.top/2020/02/28/pat-A1103/</id>
    <published>2020-02-28T11:49:20.000Z</published>
    <updated>2020-02-28T13:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224" target="_blank" rel="noopener">A1103 Integer Factorization (30分)</a></p><p>The <em>K</em>−<em>P</em> factorization of a positive integer <em>N</em> is to write <em>N</em> as the sum of the <em>P</em>-th power of <em>K</em> positive integers. You are supposed to write a program to find the <em>K</em>−<em>P</em> factorization of <em>N</em> for any positive integers <em>N</em>, <em>K</em> and <em>P</em>.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives in a line the three positive integers <em>N</em> (≤400), <em>K</em> (≤<em>N</em>) and <em>P</em> (1&lt;<em>P</em>≤7). The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, if the solution exists, output in the format:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">N</span> = <span class="built_in">n</span>[<span class="number">1</span>]^P + ... <span class="built_in">n</span>[K]^P</span><br></pre></td></tr></table></figure><p>where <code>n[i]</code> (<code>i</code> = 1, …, <code>K</code>) is the <code>i</code>-th factor. All the factors must be printed in non-increasing order.</p><p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 12<sup>2</sup>+4<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>+1<sup>2</sup>, or 11<sup>2</sup>+6<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>+2<sup>2</sup>, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence { <em>a</em>1,<em>a</em>2,⋯,<em>aK</em> } is said to be <strong>larger</strong> than { <em>b</em>1,<em>b</em>2,⋯,<em>bK</em> } if there exists 1≤<em>L</em>≤<em>K</em> such that <em>ai</em>=<em>bi</em> for <em>i</em>&lt;<em>L</em> and <em>aL</em>&gt;<em>bL</em>.</p><p>If there is no solution, simple output <code>Impossible</code>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 5 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 &#x3D; 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 167 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><ul><li>题意：整数因式分解，将一个整数N拆成K个数的P次方和，这里的P也是整数，如果找到符合的因数有多个则输出数字字典序较大的，例如 [10, 2, 1] 大于 [9, 9, 9]，因为第一个10大于9。</li><li>分析：本题考察DFS深度优先搜索，首先对于要满足的K的数的P次方和等于N，这所拆分的这几个数中最大的数要小于N，那么对于因子来说，它的P次方一样要小于N，因此在寻找这些数的时候，应该从N开P次方的数开始向下找，同时，题目要求输出满足结果中序列较大的那个，那么在DFS的时候就应该从可能的最大的数开始往下寻找。而在DFS时，存在两个分支，分别是当前数的选与不选，“死胡同”则是，当前记录的sum大于N、cntK大于K或者当前数X小于1时候，如果出现以上情况则返回。</li></ul><p>注意：DFS时因为总是要用pow函数重复计算某个数的P次幂，导致存在一个样例超时，所以需要在深搜前把可能用到的数的P次幂先计算出来，按照下标依次存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, p, maxFacSum = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, ans, fac;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sum, <span class="keyword">int</span> facSum, <span class="keyword">int</span> cntK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || sum &gt; n || cntK &gt; k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == n &amp;&amp; cntK == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (facSum &gt; maxFacSum) &#123;</span><br><span class="line">            ans = temp;</span><br><span class="line">            maxFacSum = facSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push_back(x);</span><br><span class="line">    dfs(x, sum + fac[x], facSum + x, cntK + <span class="number">1</span>);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    dfs(x - <span class="number">1</span>, sum, facSum, cntK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &lt;= n) &#123;</span><br><span class="line">        fac.push_back(temp);</span><br><span class="line">        temp = <span class="built_in">pow</span>(++i, p);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs((<span class="keyword">int</span>)fac.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d = "</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" + "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d^%d"</span>, ans[i], p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1103 Intege
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="DFS" scheme="https://blog.charjin.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1111 Online Map (30分) (Dijkstra最短路径算法)</title>
    <link href="https://blog.charjin.top/2020/02/27/pat-A1111/"/>
    <id>https://blog.charjin.top/2020/02/27/pat-A1111/</id>
    <published>2020-02-27T14:44:21.000Z</published>
    <updated>2020-03-03T15:42:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856" target="_blank" rel="noopener">A1111 Online Map (30分)</a></p><p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V1 V2 <span class="literal">one</span>-way <span class="built_in">length</span> <span class="built_in">time</span></span><br></pre></td></tr></table></figure><p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p><p>Finally a pair of source and destination is given.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">istance</span> = D: source -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> ... -&gt; destination</span><br></pre></td></tr></table></figure><p>Then in the next line print the fastest path with total time <code>T</code>:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time</span> = T: source -&gt; w1 -&gt; ... -&gt; destination</span><br></pre></td></tr></table></figure><p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p><p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distance = D; <span class="keyword">Time</span> = T: source -&gt; u1 -&gt; ... -&gt; destination</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 15</span><br><span class="line">0 1 0 1 1</span><br><span class="line">8 0 0 1 1</span><br><span class="line">4 8 1 1 1</span><br><span class="line">3 4 0 3 2</span><br><span class="line">3 9 1 4 1</span><br><span class="line">0 6 0 1 1</span><br><span class="line">7 5 1 2 1</span><br><span class="line">8 5 1 2 1</span><br><span class="line">2 3 0 2 2</span><br><span class="line">2 1 1 1 1</span><br><span class="line">1 3 0 3 1</span><br><span class="line">1 4 0 1 1</span><br><span class="line">9 7 1 3 1</span><br><span class="line">5 1 0 5 2</span><br><span class="line">6 5 1 1 2</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Distance &#x3D; 6: 3 -&gt; 4 -&gt; 8 -&gt; 5</span><br><span class="line">Time &#x3D; 3: 3 -&gt; 1 -&gt; 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">0 4 1 1 1</span><br><span class="line">1 6 1 1 3</span><br><span class="line">2 6 1 1 1</span><br><span class="line">2 5 1 2 2</span><br><span class="line">3 0 0 1 1</span><br><span class="line">3 1 1 1 3</span><br><span class="line">3 2 1 1 2</span><br><span class="line">4 5 0 2 2</span><br><span class="line">6 5 1 1 2</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distance &#x3D; 3; Time &#x3D; 4: 3 -&gt; 2 -&gt; 5</span><br></pre></td></tr></table></figure><ul><li>题意：一张网络地图，给定起点和终点，找到距离最短和用时最少的路径，如果最短路径不唯一则找用时最短的，如果用时最少的路径不唯一则找顶点最少的。</li><li>分析：这题用两次Dijkstra算法就好了，根据题意把路径记录下来存在<code>dispre</code>和<code>timepre</code>中，之后递归输出路径结果，因为路径相等的情况下是一行输出，而且是用<code>vector</code>存的，所以直接用<code>==</code>比较是否相等即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="keyword">int</span> n, m, st, dest, Dist[N][N], Time[N][N], d[N], t[N], num[N];</span><br><span class="line">vector&lt;int&gt; dispre(N), timepre(N), dispath, timepath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraDistance</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) dispre[i] = i;</span><br><span class="line">    fill(d, d + N, INF);</span><br><span class="line">    fill(t, t + N, INF);</span><br><span class="line">    d[s] = t[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; d[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + Dist[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + Dist[u][v];</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    dispre[v] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + Dist[u][v] == d[v] &amp;&amp; t[u] + Time[u][v] &lt; t[v]) &#123;</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    dispre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraTime</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) timepre[i] = i;</span><br><span class="line">    fill(num, num + N, INF);</span><br><span class="line">    fill(t, t + N, INF);</span><br><span class="line">    num[s] = t[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; t[i] &lt; MIN) &#123;</span><br><span class="line">                u = i;</span><br><span class="line">                MIN = t[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[u] + Time[u][v] &lt; t[v]) &#123;</span><br><span class="line">                    t[v] = t[u] + Time[u][v];</span><br><span class="line">                    num[v] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    timepre[v] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[u] + Time[u][v] == t[v] &amp;&amp; num[u] + <span class="number">1</span> &lt; num[v]) &#123;</span><br><span class="line">                    num[v] = num[u] + <span class="number">1</span>;</span><br><span class="line">                    timepre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == st) &#123;</span><br><span class="line">        path.push_back(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsPath(pre, path, pre[u]);</span><br><span class="line">    path.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, path[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b, oneway, len, time;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;a, &amp;b, &amp;oneway, &amp;len, &amp;time);</span><br><span class="line">        e[a].push_back(b);</span><br><span class="line">        <span class="keyword">if</span> (oneway == <span class="number">0</span>) e[b].push_back(a);</span><br><span class="line">        Dist[a][b] = Dist[b][a] = len;</span><br><span class="line">        Time[a][b] = Time[b][a] = time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;dest);</span><br><span class="line">    dijkstraDistance(st);</span><br><span class="line">    dijkstraTime(st);</span><br><span class="line">    dfsPath(dispre, dispath, dest);</span><br><span class="line">    dfsPath(timepre, timepath, dest);</span><br><span class="line">    <span class="keyword">if</span> (dispath == timepath) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: "</span>, d[dest], t[dest]);</span><br><span class="line">        printPath(dispath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: "</span>, d[dest]);</span><br><span class="line">        printPath(dispath);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Time = %d: "</span>, t[dest]);</span><br><span class="line">        printPath(timepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1111 Online
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="Dijkstra最短路径算法" scheme="https://blog.charjin.top/tags/Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1123 Is It a Complete AVL Tree (30分) (完全AVL树判定)</title>
    <link href="https://blog.charjin.top/2020/02/26/pat-A1123/"/>
    <id>https://blog.charjin.top/2020/02/26/pat-A1123/</id>
    <published>2020-02-26T08:52:55.000Z</published>
    <updated>2020-03-03T15:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805351302414336" target="_blank" rel="noopener">A1123 Is It a Complete AVL Tree (30分)</a></p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><table><thead><tr><th><img src="https://images.ptausercontent.com/fb337acb-93b0-4af2-9838-deff5ce98058.jpg" alt="F1.jpg"></th><th><img src="https://images.ptausercontent.com/d1635de7-3e3f-4aaa-889b-ba29f35890db.jpg" alt="F2.jpg"></th></tr></thead><tbody><tr><td><img src="https://images.ptausercontent.com/e868e4b9-9fea-4f70-b7a7-1f5d8a3be4ef.jpg" alt="F3.jpg"></td><td><img src="https://images.ptausercontent.com/98aa1782-cea5-4792-8736-999436cf43a9.jpg" alt="F4.jpg"></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 63 65</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">70 63 88 61 65</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88 65 96 61 70 90 120 68</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><ul><li>题意：给定插入结点的顺序，将其构建成平衡二叉树，输出这棵AVL树的层序遍历序列，并判断这棵树是不是完全二叉树。</li><li>分析：这题考察的是AVL树的构建和以及完全二叉树的判定。</li></ul><ol start="0"><li>AVL本身是二叉搜索树，为了防止出现一边倒的情况，在插入结点到二叉搜索树的同时，对这棵树做相应调整，使这棵树的任意子树均保持左右子树高度差不超过1的特性。</li><li>对树的调整有4种形态。FIgure1所示，则直接从根节点右旋即可；Figure2所示，则是以88为根的结点需要左旋，而根结点70不需要调整；Figure3所示，则是先将以96为根的子树做右旋，把它调整为右侧较重的形状，之后对70为根的树左旋，刚好又能变得平衡；Figure4则是对以70为根的子树做右旋。</li><li>AVL树构建完成后，层序遍历则是BFS这棵树就行了，这里还要解决问题的是在层序遍历的同时对其是否为完全二叉树做判断。因为这里事先就知道这棵树的结点数了，在对结点做输出的时候，每输出一个结点，cnt就会加1，这里对任意非叶子结点不管其左右孩子谁为空，都将其放进队列中，那么如果是完全二叉树，在遍历的过程中，即cnt未到达n的时队列中一定不会出现NULL元素，由此便可判断其是否为完全二叉树了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, height;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">        left = right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node *&amp;root)</span> </span>&#123;</span><br><span class="line">    node *temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node *&amp;root)</span> </span>&#123;</span><br><span class="line">    node *temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;data) &#123;</span><br><span class="line">        insert(root-&gt;left, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="number">-1</span>) L(root-&gt;left);</span><br><span class="line">            R(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;right, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="number">1</span>) R(root-&gt;right);</span><br><span class="line">            L(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(node *root, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> iscbt = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node *now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n &amp;&amp; now == <span class="literal">NULL</span>) iscbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (now) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, now-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (++cnt &lt; n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            q.push(now-&gt;left);</span><br><span class="line">            q.push(now-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%s"</span>, iscbt ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        insert(root, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(root, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805351302414336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1123 Is It 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="平衡二叉树" scheme="https://blog.charjin.top/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="AVL" scheme="https://blog.charjin.top/tags/AVL/"/>
    
      <category term="完全二叉树" scheme="https://blog.charjin.top/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="完全平衡二叉树" scheme="https://blog.charjin.top/tags/%E5%AE%8C%E5%85%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python实现博客站点url实时推送至百度与Linux定时任务</title>
    <link href="https://blog.charjin.top/2020/02/26/hexo-baidu-activepush/"/>
    <id>https://blog.charjin.top/2020/02/26/hexo-baidu-activepush/</id>
    <published>2020-02-26T00:24:56.000Z</published>
    <updated>2020-02-26T03:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于<a href="https://blog.charjin.top/2020/02/05/hexo-site-autopush/">【Hexo】maupassant 主题设置百度站点自动推送</a> 的博客</p><p>这种自动推送的方式也只有在页面受访时才会被提交至百度，只可惜百度对个人博客url的收录速度确实无法跟Google比呀，因此编写Python脚本通过站点的 <strong>sitemap.xml</strong> 与Linux定时任务实现 <strong>主动推送</strong> 的自动化。具体步骤如下：</p><h1 id="链接提交方式的对比"><a href="#链接提交方式的对比" class="headerlink" title="链接提交方式的对比"></a>链接提交方式的对比</h1><p>可转至 <a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title9" target="_blank" rel="noopener">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title9</a> ，百度搜索资源平台查看链接提交方式的效果差异：</p><ul><li>主动推送：最为 <strong>快速</strong> 的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li>sitemap： 您可以定期将网站链接放到Sitemap中，然后将Sitemap提交给百度。百度会周期性的抓取检查您提交的Sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</li><li>手工提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。</li><li>自动推送：是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。</li></ul><p>对于以上的sitemap与自动推送方式，此前博主已设置过该方式，但链接提交速度还是不如主动推送。</p><h1 id="个人博客生成sitemap站点地图"><a href="#个人博客生成sitemap站点地图" class="headerlink" title="个人博客生成sitemap站点地图"></a>个人博客生成sitemap站点地图</h1><p>首先，引用百度关于主动推动的相关格式：</p><blockquote><h3 id="推送接口"><a href="#推送接口" class="headerlink" title="推送接口"></a>推送接口</h3><p>接口调用地址：<a href="http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识</a></p><table><thead><tr><th align="left">参数名称</th><th align="left">是否必选</th><th align="left">参数类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">site</td><td align="left">是</td><td align="left">string</td><td align="left">在搜索资源平台验证的站点，比如<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></td></tr><tr><td align="left">token</td><td align="left">是</td><td align="left">string</td><td align="left">在搜索资源平台申请的推送用的准入密钥</td></tr></tbody></table><h3 id="推送示例"><a href="#推送示例" class="headerlink" title="推送示例"></a>推送示例</h3><ul><li><p>curl推送示例</p></li><li><p><strong>将要提交的链接按照每行一条的格式写入一个文本文件中，命名此文件为urls.txt，然后进入该文件所在目录，执行如下命令：</strong></p><p>curl -H ‘Content-Type:text/plain’ –data-binary @urls.txt “<a href="http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识&quot;" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?site=个人博客地址&amp;token=每个站长有唯一的标识&quot;</a></p></li></ul></blockquote><p>这里要求编写一个 <strong>urls.txt</strong> 文件存放我们想要提交的url。自己手动输入url是件很麻烦的事，因此想到不如从sitemap中提取所有站点url。</p><p>来访搭建了个人博客的博主应该都知道怎么生成sitemap，这里还是简要说明一下，以 <strong>Hexo</strong> 博客框架举例，在博客根目录执行以下代码安装sitemap生成插件：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>之后编辑Hexo博客根目录下的 <strong>_config.yml</strong> 文件，添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>安装sitemap生成插件，部署站点后，通过 <strong>https://<u>你的博客url/sitemap.xml</u></strong> 即可访问到 sitemap.xml。</p><h1 id="通过Python提取urls并写入文件"><a href="#通过Python提取urls并写入文件" class="headerlink" title="通过Python提取urls并写入文件"></a>通过Python提取urls并写入文件</h1><p>现在已生成了sitemap，要做的就是将其中所有的url解析出来写入到某个urls.txt文件中。之后再按照百度的要求执行curl命令即可。</p><p>使用到的第三方Python库：Requests</p><p>在Linux环境下（CentOS）需要执行以下代码安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python3# 如果没有python则需要先安装</span><br><span class="line">sudo pip3 install requests# 安装 requests 库</span><br></pre></td></tr></table></figure><ul><li>代码相关说明： 务必在执行前，修改以下代码中的<code>blog_url</code>和<code>token</code>两个变量，其中<code>token</code>需要先到百度站长中心添加自己的网站才能获取。</li><li>代码基本思路：<ol start="0"><li>通过 <strong>requests</strong> 库将个人站点sitemap中的urls解析出来并到用户目录下的 <strong>urls.txt</strong> 文件中</li><li>通过 <strong>os</strong> 库执行命令，将命令执行后的输出按行写入到用户目录下的 <strong>submit_log.txt</strong> 文件中，以保存作为链接的提交日志。同时记录提交的次数和时间。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> et</span><br><span class="line"></span><br><span class="line"><span class="comment"># 务必设定以下两项配置</span></span><br><span class="line">blog_url = <span class="string">'你的博客地址'</span>  <span class="comment"># e.g: blog.charjin.top (不添加http或https)</span></span><br><span class="line">token = <span class="string">'百度搜索资源申请推送的准入密钥'</span> <span class="comment"># e.g: QfemDubDm5aArbp1 (在此处查看https://ziyuan.baidu.com/linksubmit)</span></span><br><span class="line"></span><br><span class="line">userdir = os.path.expanduser(<span class="string">'~'</span>)   <span class="comment"># 获取用户目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取sitemap.xml提取url写至本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseSitemapToFile</span><span class="params">(sitemap_url)</span>:</span></span><br><span class="line">    r = requests.get(sitemap_url)</span><br><span class="line">    r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    urlset = et.fromstring(r.text)  <span class="comment"># sitemap根元素为urlset</span></span><br><span class="line"></span><br><span class="line">    file = open(userdir + <span class="string">'/urls.txt'</span>, <span class="string">'w'</span>)  <span class="comment"># 写的形式打开文件, 不存在则自动创建</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urlset:</span><br><span class="line">        file.write(url[<span class="number">0</span>].text + <span class="string">'\n'</span>)  <span class="comment"># 逐行写入链接</span></span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parseSitemapToFile(<span class="string">'https://%s/sitemap.xml'</span> % blog_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命令</span></span><br><span class="line">cmd = <span class="string">'curl -H \'Content-Type:text/plain\' --data-binary @%s/urls.txt \</span></span><br><span class="line"><span class="string">"http://data.zz.baidu.com/urls?site=%s&amp;token=%s"'</span> % (userdir, blog_url, token)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令并获取输出结果</span></span><br><span class="line">cmt_output = os.popen(cmd).readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取原文件行数便于追加记录, 如果不存在则初始化为0</span></span><br><span class="line">cnt_line = <span class="number">0</span> <span class="keyword">if</span> os.path.exists(userdir + <span class="string">'/submit_log.txt'</span>) == <span class="literal">False</span> <span class="keyword">else</span> len(</span><br><span class="line">    open(userdir + <span class="string">'/submit_log.txt'</span>, <span class="string">'r'</span>).readlines())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间用于日志记录</span></span><br><span class="line">current_time = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以append形式打开文件</span></span><br><span class="line">file_log = open(userdir + <span class="string">'/submit_log.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按格式和序号将提交日志写入文件</span></span><br><span class="line">file_log.write(str(cnt_line + <span class="number">1</span>) + <span class="string">'. '</span> + current_time + <span class="string">' - result: '</span> + cmt_output[<span class="number">0</span>] + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file_log.close()</span><br></pre></td></tr></table></figure><h1 id="通过Linux服务器执行定时任务"><a href="#通过Linux服务器执行定时任务" class="headerlink" title="通过Linux服务器执行定时任务"></a>通过Linux服务器执行定时任务</h1><p>既然有个人站点，必定是已购买了个人服务器的，所以应充分发挥服务器的作用，哈哈。</p><p>仅以CentOS举例：</p><ul><li>将在本地写好的python代码（此处文件名为 activepush.py ）复制到服务器的用户目录之下：（也可在服务器中直接编辑创建）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp activepush.py 服务器名:~/</span><br></pre></td></tr></table></figure><ul><li>假设是以 <strong>root</strong> 用户登录的，现在cd至<code>/etc/cron.daily</code>目录下，实际上通过tab补全可以看到有多个cron的目录。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/cron.</span><br><span class="line">cron.d/        cron.daily/    cron.hourly/   cron.monthly/  cron.weekly/</span><br></pre></td></tr></table></figure><p>这里不同目录下分别存放的是每天、每周、每小时等等执行的脚本文件。因此进入<code>/etc/cron.hourly</code>目录后，通过vim在其中创建shell脚本文件: <code>vim activepush</code>，在该文件中输入以下命令，之后 <code>:qw</code>退出并保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 存放python代码的目录/activepush.py</span><br></pre></td></tr></table></figure><ul><li>最后要让创建的shell脚本可执行，通过chmod修改权限（为了方便设为对所有用户都可执行）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x activepush</span><br></pre></td></tr></table></figure><p>OK，最后昨天凌晨挂上去的，现在查看一下日志文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@server-char]~# cat urls.txt</span><br><span class="line">https://blog.charjin.top/2020/02/25/PAT-A1131/</span><br><span class="line">https://blog.charjin.top/2020/02/25/PAT-A1127/</span><br><span class="line">https://blog.charjin.top/2020/02/24/pat-A1135/</span><br><span class="line">....一共有55条...这里省略了</span><br><span class="line"></span><br><span class="line">[root@server-char]~# cat submit_log.txt</span><br><span class="line">1. 2020-02-26 02:01:04 - result: &#123;"remain":99065,"success":55&#125;</span><br><span class="line">2. 2020-02-26 03:01:01 - result: &#123;"remain":99010,"success":55&#125;</span><br><span class="line">3. 2020-02-26 04:01:05 - result: &#123;"remain":98955,"success":55&#125;</span><br><span class="line">4. 2020-02-26 05:01:05 - result: &#123;"remain":98900,"success":55&#125;</span><br><span class="line">5. 2020-02-26 06:01:06 - result: &#123;"remain":98845,"success":55&#125;</span><br><span class="line">6. 2020-02-26 07:01:05 - result: &#123;"remain":98790,"success":55&#125;</span><br><span class="line">7. 2020-02-26 08:01:03 - result: &#123;"remain":98735,"success":55&#125;</span><br><span class="line">8. 2020-02-26 09:01:04 - result: &#123;"remain":98680,"success":55&#125;</span><br><span class="line">9. 2020-02-26 10:01:05 - result: &#123;"remain":98625,"success":55&#125;</span><br><span class="line">10. 2020-02-26 11:01:04 - result: &#123;"remain":98460,"success":55&#125;</span><br></pre></td></tr></table></figure><p>每小时提交一次，一共提交10次了，这里remain是百度说每日剩余可提交的url数量，但是似乎是每天10万条，怎么提交也不会超过。</p><p>现在我的站点将主动推送也自动化了，集结了主动推送、自动推送以及sitemap自动抓取，这回还不努力收录我的urls，我真要对百度失望了。</p><p>最后，似乎完成对全站的https认证才能提高链接的收录几率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写过一篇关于&lt;a href=&quot;https://blog.charjin.top/2020/02/05/hexo-site-autopush/&quot;&gt;【Hexo】maupassant 主题设置百度站点自动推送&lt;/a&gt; 的博客&lt;/p&gt;
&lt;p&gt;这种自动推送的方式也只有在页面受访时
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.charjin.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="博客" scheme="https://blog.charjin.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://blog.charjin.top/tags/Hexo/"/>
    
      <category term="站点url自动推送" scheme="https://blog.charjin.top/tags/%E7%AB%99%E7%82%B9url%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1127 ZigZagging on a Tree (30分) (不建树)</title>
    <link href="https://blog.charjin.top/2020/02/25/pat-A1127/"/>
    <id>https://blog.charjin.top/2020/02/25/pat-A1127/</id>
    <published>2020-02-25T14:57:23.000Z</published>
    <updated>2020-02-27T12:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016" target="_blank" rel="noopener">A1127 ZigZagging on a Tree (30分)</a></p><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p><p><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg"></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12 11 20 17 1 15 8 5</span><br><span class="line">12 20 17 11 15 8 5 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 11 5 8 17 12 20 15</span><br></pre></td></tr></table></figure><ul><li>题意：给一个二叉树的后序和中序遍历序列，要求输出这棵树的 “Z” 字形遍历序列。</li><li>分析：这题不需要建树，只用在二叉树中后序序列建树方法的基础上加上<code>depth</code>参数用以记录深度即可，然后通过<code>vector</code>数组依次记录每一层的结点，因为无论前中后遍历二叉树的访问序列都是从上至下从左至右，所以push进<code>vector[层数]</code>同样是按照同一层结点间的顺序的，因此该方式可行，同时在建树方法中记录下出现的最大层数。为了方便记录（其实也差不多），第一层的depth被记为0。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> post[N], in[N], maxDepth = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl, <span class="keyword">int</span> postr, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postl &gt; postr) <span class="keyword">return</span>;</span><br><span class="line">    maxDepth = max(maxDepth, depth);</span><br><span class="line">    ans[depth].push_back(post[postr]);</span><br><span class="line">    <span class="keyword">int</span> k = inl;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= inr &amp;&amp; in[k] != post[postr]) k++;</span><br><span class="line">    <span class="keyword">int</span> numleft = k - inl;</span><br><span class="line">    create(postl, postl + numleft - <span class="number">1</span>, inl, k - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    create(postl + numleft, postr - <span class="number">1</span>, k + <span class="number">1</span>, inr, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxDepth; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) reverse(ans[i].begin(), ans[i].end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : ans[i]) <span class="built_in">printf</span>(<span class="string">" %d"</span>, it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1127 ZigZag
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://blog.charjin.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="DFS" scheme="https://blog.charjin.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1131 Subway Map (30分) (DFS深度优先搜索+剪枝)</title>
    <link href="https://blog.charjin.top/2020/02/25/pat-A1131/"/>
    <id>https://blog.charjin.top/2020/02/25/pat-A1131/</id>
    <published>2020-02-25T12:33:25.000Z</published>
    <updated>2020-03-03T15:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432" target="_blank" rel="noopener">A1131 Subway Map (30分)</a></p><p>In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.</p><p><img src="https://images.ptausercontent.com/55799c23-4bdb-4e32-af7f-6d41accfdd2b.jpg" alt=""></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤ 100), the number of subway lines. Then <em>N</em> lines follow, with the <em>i</em>-th (<em>i</em>=1,⋯,<em>N</em>) line describes the <em>i</em>-th subway line in the format:</p><p><em>M</em> S[1] S[2] … S[<em>M</em>]</p><p>where <em>M</em> (≤ 100) is the number of stops, and S[<em>i</em>]’s (<em>i</em>=1,⋯,<em>M</em>) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order – that is, the train travels between S[<em>i</em>] and S[<em>i</em>+1] (<em>i</em>=1,⋯,<em>M</em>−1) without any stop.</p><p>Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines.</p><p>After the description of the subway, another positive integer <em>K</em> (≤ 10) is given. Then <em>K</em> lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.</p><p>The following figure shows the sample map.</p><p><img src="https://images.ptausercontent.com/932c8f1b-7dd5-489d-a774-a91c1fabba7f.jpg" alt=""></p><p>Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Take Line#X1 from S1 to S2.</span><br><span class="line">Take Line#X2 from S2 to S3.</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>where <code>X</code><em>i</em>‘s are the line numbers and <code>S</code><em>i</em>‘s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.</p><p>If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7 1001 3212 1003 1204 1005 1306 7797</span><br><span class="line">9 9988 2333 1204 2006 2005 2004 2003 2302 2001</span><br><span class="line">13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011</span><br><span class="line">4 6666 8432 4011 1306</span><br><span class="line">3</span><br><span class="line">3011 3013</span><br><span class="line">6666 2001</span><br><span class="line">2004 3001</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Take Line#3 from 3011 to 3013.</span><br><span class="line">10</span><br><span class="line">Take Line#4 from 6666 to 1306.</span><br><span class="line">Take Line#3 from 1306 to 2302.</span><br><span class="line">Take Line#2 from 2302 to 2001.</span><br><span class="line">6</span><br><span class="line">Take Line#2 from 2004 to 1204.</span><br><span class="line">Take Line#1 from 1204 to 1306.</span><br><span class="line">Take Line#3 from 1306 to 3001.</span><br></pre></td></tr></table></figure><ul><li>题意：给了一张地铁图，对任意给定的起点和终点，找到一条乘车方案，使行经站最少，如果有多个路线符合则输出换乘最少的（题目保证这是唯一的）。</li><li>分析：这题实际上是个纸老虎，考察的是图的DFS，但是有不少需要注意的点（坑）。</li></ul><p>主要有以下几步：</p><ol start="0"><li>用什么方式表示这张图。因为题目中图的编号不是连续的，而且每个顶点的编号是四位数，所以这里要选用邻接表来存储图。</li><li>怎么找到路径并剪枝。如果只是用图的DFS遍历的话，那只能找到一条从起点到终点的路径，因为每个顶点只访问一次。首先这里铁路图肯定是连通图，之后，原来深度优先搜索的算法是走到哪个顶点就把那个点标记为已访问过，所以额外要改动的就是从某个顶点递归的DFS后再重新把这个点标记为可访问即可。同时，在DFS寻找所有路径的时候，为了适当缩短查找时间在DFS时添加<code>cntStop</code>参数记录当前结点的深度（实际上就是搭乘的站数），如果已经超过了之前记录的最小站数则提前退出，这一步是剪枝。</li><li>怎么计算换乘次数。要知道是否换乘就要知道乘车过程中线路是不是发生了改变，因为相邻的两个点肯定会在一条线路上，所以读入数据的时候需要保存相邻两点的线路编号，起初想法是用二维数组记录线路，但是如果是换乘点则至少会在两条线路上，所以使用哈希表通过 <strong>编号1 * 10000 + 编号2</strong> 作为键来标记这两点间的线路，同时从编号2到编号1亦需标记。之后计算换乘次数则先用<code>preline</code>变量记录初始的线路，随后从第二站开始遍历路径，如果发现线路改变则<code>cnt</code>加1，同时更新<code>preline</code>。</li><li>最后输出时，要求的只输出起点、换乘站和终点，因此思路和之前计算换乘次数是一致的，也是用<code>preline</code>先记录最开始的线路，同时这里还要用是<code>preStop</code>记录上一个输出的换乘站，最后还要输出最后一个换乘站到终点的记录就好了。</li></ol><p>注意点：起初在dfs中判断是否更新最少乘车站时，如果乘车站数比之前记录的还要少，除了要更新最少乘车站数，也要把最少换乘数更新成当前这条线路的换乘数，因为乘车站数是第一尺标，换乘站是跟着它一起的呀，最开始没有更新，虽然只有两个测试点没过，但只有10分 ~_~！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, st, dest, minCntStop, minCntTransfer;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; line;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N], path, tempPath;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTransferCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preline = line[v[<span class="number">0</span>] * <span class="number">10000</span> + v[<span class="number">1</span>]], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowline = line[v[i] * <span class="number">10000</span> + v[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span> (nowline != preline) &#123;</span><br><span class="line">            preline = nowline;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cntStop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cntStop &gt; minCntStop) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    tempPath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span> (u == dest) &#123;</span><br><span class="line">        <span class="keyword">int</span> cntTransfer = getTransferCount(tempPath);</span><br><span class="line">        <span class="keyword">if</span> (cntStop &lt; minCntStop || cntTransfer &lt; minCntTransfer) &#123;</span><br><span class="line">            minCntTransfer = cntTransfer;</span><br><span class="line">            minCntStop = cntStop;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> next : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[next]) &#123;</span><br><span class="line">            dfs(next, cntStop + <span class="number">1</span>);</span><br><span class="line">            vis[next] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preStop, stop;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;preStop);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stop);</span><br><span class="line">            e[preStop].push_back(stop);</span><br><span class="line">            e[stop].push_back(preStop);</span><br><span class="line">            line[preStop * <span class="number">10000</span> + stop] = line[stop * <span class="number">10000</span> + preStop] = i;</span><br><span class="line">            preStop = stop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;dest);</span><br><span class="line">        tempPath.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        minCntStop = minCntTransfer = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        fill(vis, vis + N, <span class="literal">false</span>);</span><br><span class="line">        dfs(st, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> preline = line[path[<span class="number">0</span>] * <span class="number">10000</span> + path[<span class="number">1</span>]], preStop = path[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nowline = line[path[i] * <span class="number">10000</span> + path[i + <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (nowline != preline) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preline, preStop, path[i]);</span><br><span class="line">                preline = nowline;</span><br><span class="line">                preStop = path[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preline, preStop, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1131 Subway
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="DFS" scheme="https://blog.charjin.top/tags/DFS/"/>
    
      <category term="深度优先搜索" scheme="https://blog.charjin.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1135 Is It A Red-Black Tree (30分) (DFS深度优先搜索)</title>
    <link href="https://blog.charjin.top/2020/02/24/pat-A1135/"/>
    <id>https://blog.charjin.top/2020/02/24/pat-A1135/</id>
    <published>2020-02-24T09:00:21.000Z</published>
    <updated>2020-03-03T15:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640" target="_blank" rel="noopener">A1135 Is It A Red-Black Tree (30分)</a></p><p>There is a kind of balanced binary search tree named <strong>red-black tree</strong> in the data structure. It has the following 5 properties:</p><ul><li>(1) Every node is either red or black.</li><li>(2) The root is black.</li><li>(3) Every leaf (NULL) is black.</li><li>(4) If a node is red, then both its children are black.</li><li>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li></ul><p>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</p><table><thead><tr><th align="center"><img src="https://images.ptausercontent.com/eff80bd4-c833-4818-9786-81680d1b304a.jpg" alt=""></th><th align="center"><img src="https://images.ptausercontent.com/b11184df-eaab-451c-b7d4-7fc1dc82b028.jpg" alt=""></th><th align="center"><img src="https://images.ptausercontent.com/625c532b-22fc-47b9-80ea-0537cf00d922.jpg" alt=""></th></tr></thead><tbody><tr><td align="center">Figure 1</td><td align="center">Figure 2</td><td align="center">Figure 3</td></tr></tbody></table><p>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">7 -2 1 5 -4 -11 8 14 -15</span><br><span class="line">9</span><br><span class="line">11 -2 1 -7 5 -4 8 14 -15</span><br><span class="line">8</span><br><span class="line">10 -7 5 -6 8 15 -11 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><ul><li><p>题意：题目给出了红黑树的定义：</p><ul><li>（1）每个节点都是红色或黑色。</li><li>（2）根是黑色的。</li><li>（3）每片叶子（NULL）是黑色的。</li><li>（4）如果节点为红色，则其两个子节点均为黑色。</li><li>（5）对于每个节点，从节点到后代叶子的所有简单路径都包含相同数量的黑色节点。</li></ul><p>通过红黑树的定义判断给出的二叉搜索树是不是红黑树；所有结点值都是正整数，用正负号表示颜色（负号为红色）。</p></li><li><p>分析：这道题实际上考察的不是红黑树，要不然甲级就超纲啦，哈哈。题目给了二叉搜索树的先序遍历序列，先根据BST的特性建树（链式存储）。之后判断，如果根是红色则不是红黑树，否则就从根节点开始深度优先，在途中如果发现某个结点是红色，其孩子也出现红色，则把 <code>isrbt</code>标记为false，同时传入参数cnt记录从根节点到叶子结点上黑色结点的个数，当到达递归边界的时候（即空结点）判断从根节点到当前位置上的黑色结点数cnt是不是和之前记录过的cntBlack相等，如果不等则标记<code>isrbt</code>为false，但如果之前没记录过cntBlack（即cntBlack为-1）则不作判断。</p></li></ul><p>注意：1. 插入结点时，传入的root需要使用引用类型。2. 因为有多个序列要判断，所以每次DFS前都要重置<code>isrbt</code>和<code>cntBlack</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    node(<span class="keyword">int</span> x) : data(x) &#123; left = right = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(x) &lt; <span class="built_in">abs</span>(root-&gt;data)) insert(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> insert(root-&gt;right, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> isrbt;</span><br><span class="line"><span class="keyword">int</span> cntBlack = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(node* root, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cntBlack == <span class="number">-1</span>) cntBlack = cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cntBlack != cnt) isrbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;data &lt; <span class="number">0</span>) isrbt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;data &lt; <span class="number">0</span>) isrbt = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;left, root-&gt;data &gt; <span class="number">0</span> ? cnt + <span class="number">1</span> : cnt);</span><br><span class="line">    dfs(root-&gt;right, root-&gt;data &gt; <span class="number">0</span> ? cnt + <span class="number">1</span> : cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        node* root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            insert(root, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;data &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            isrbt = <span class="literal">true</span>;</span><br><span class="line">            cntBlack = <span class="number">-1</span>;</span><br><span class="line">            dfs(root, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isrbt ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1135 Is It 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="红黑树的判别" scheme="https://blog.charjin.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A4%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1143 Lowest Common Ancestor (30分)</title>
    <link href="https://blog.charjin.top/2020/02/24/pat-A1143/"/>
    <id>https://blog.charjin.top/2020/02/24/pat-A1143/</id>
    <published>2020-02-24T06:19:55.000Z</published>
    <updated>2020-02-24T06:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312" target="_blank" rel="noopener">A1143 Lowest Common Ancestor (30分)</a></p><p>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.</p><p>A binary search tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Given any two nodes in a BST, you are supposed to find their LCA.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of <strong>int</strong>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given pair of U and V, print in a line <code>LCA of U and V is A.</code> if the LCA is found and <code>A</code> is the key. But if <code>A</code> is one of U and V, print <code>X is an ancestor of Y.</code> where <code>X</code> is <code>A</code> and <code>Y</code> is the other node. If U or V is not found in the BST, print in a line <code>ERROR: U is not found.</code> or <code>ERROR: V is not found.</code> or <code>ERROR: U and V are not found.</code>.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">6 3 1 2 5 4 8 7</span><br><span class="line">2 5</span><br><span class="line">8 7</span><br><span class="line">1 9</span><br><span class="line">12 -3</span><br><span class="line">0 8</span><br><span class="line">99 99</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCA of 2 and 5 is 3.</span><br><span class="line">8 is an ancestor of 7.</span><br><span class="line">ERROR: 9 is not found.</span><br><span class="line">ERROR: 12 and -3 are not found.</span><br><span class="line">ERROR: 0 is not found.</span><br><span class="line">ERROR: 99 and 99 are not found.</span><br></pre></td></tr></table></figure><ul><li>题意：给一个二叉搜索树的先序遍历序列，给出任意两结点值找到其最低公共祖先。</li><li>分析：根据二叉搜索树的特性，按照题目中的定义，其根结点总是大于左子树的所有结点，且总大于或等于其右子树的所有结点。那么在寻找a、b结点的最低公共祖先时候可以遍历这棵树的所有结点，找到其值介于a、b之间（可等）的结点即可，因为给出的结点可能并不存在于树中，所以在读入先序序列的时候可以先对树中的结点做标记。之后如果不存在该结点便可直接判断。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; exist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">        exist[pre[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (!exist[a] &amp;&amp; !exist[b]) <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!exist[a] || !exist[b]) <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, !exist[a] ? a : b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                ans = pre[i];</span><br><span class="line">                <span class="keyword">if</span> ((ans &gt;= a &amp;&amp; ans &lt;= b) || (ans &gt;= b &amp;&amp; ans &lt;= a)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a == ans || b == ans) <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, ans, a == ans ? b : a);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, a, b, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1143 Lowest
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="二叉树最低公共祖先" scheme="https://blog.charjin.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
      <category term="LCA" scheme="https://blog.charjin.top/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1147 Heaps (30分) (堆的判定)</title>
    <link href="https://blog.charjin.top/2020/02/24/pat-A1147/"/>
    <id>https://blog.charjin.top/2020/02/24/pat-A1147/</id>
    <published>2020-02-24T04:40:55.000Z</published>
    <updated>2020-03-03T15:45:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>PAT甲级：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">A1147 Heaps (30分)</a></p><p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>)</p><p>Your job is to tell if a given complete binary tree is a heap.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 100), the number of trees to be tested; and N (1 &lt; N ≤ 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given tree, print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all. Then in the next line print the tree’s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 8</span><br><span class="line">98 72 86 60 65 12 23 50</span><br><span class="line">8 38 25 58 52 82 70 60</span><br><span class="line">10 28 15 12 34 9 8 56</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Max Heap</span><br><span class="line">50 60 65 72 12 23 86 98</span><br><span class="line">Min Heap</span><br><span class="line">60 58 52 38 82 70 25 8</span><br><span class="line">Not Heap</span><br><span class="line">56 12 34 28 9 8 15 10</span><br></pre></td></tr></table></figure><ul><li>题意：给出一颗完全二叉树顺序存储的序列，判断这棵树是大顶堆、小顶堆或不是堆，之后输出这完全二叉树的后序遍历序列。</li><li>分析：因为是完全二叉树且是顺序存储的方式，所以从下标为1的位置开始依次读入到heap数组中，之后设定<code>isMaxHeap</code>、<code>isMinHeap</code>两变量，从下标为2的结点开始，遍历该数组，当前结点编号 i 除以2就是父结点编号，如果孩子结点值大于父结点值则一定不是大顶堆，将<code>isMaxHeap</code>标记为 <strong>false</strong>，小顶堆同理。最后递归输出后序遍历序列。</li></ul><p>注意：输出后序遍历序列最后不能有多余空格，因此设置全局变量<code>cnt</code>判断是否输出空格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, cnt = <span class="number">0</span>, heap[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(i * <span class="number">2</span>);</span><br><span class="line">    postOrder(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, heap[i]);</span><br><span class="line">    <span class="keyword">if</span> (++cnt &lt; n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[j]);</span><br><span class="line">        <span class="keyword">bool</span> isMaxHeap = <span class="literal">true</span>, isMinHeap = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &gt; heap[i / <span class="number">2</span>]) isMaxHeap = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &lt; heap[i / <span class="number">2</span>]) isMinHeap = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isMaxHeap &amp;&amp; !isMinHeap) <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, isMaxHeap ? <span class="string">"Max Heap"</span> : <span class="string">"Min Heap"</span>);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        postOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PAT甲级：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A1147 Heaps 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://blog.charjin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT" scheme="https://blog.charjin.top/tags/PAT/"/>
    
      <category term="堆" scheme="https://blog.charjin.top/tags/%E5%A0%86/"/>
    
      <category term="堆的判定" scheme="https://blog.charjin.top/tags/%E5%A0%86%E7%9A%84%E5%88%A4%E5%AE%9A/"/>
    
  </entry>
  
</feed>
